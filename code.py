# 89375480
"""
Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере.
Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время.
Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности.
Теперь массив не является отсортированным. Тем не менее, нужно обеспечить возможность находить в нем элемент за
O(logn).
Можно предполагать, что в массиве только уникальные элементы.

Формат ввода
Функция принимает массив натуральных чисел и искомое число
k. Длина массива не превосходит 10000. Элементы массива и число k не превосходят по значению 10000.
В примерах:
В первой строке записано число n –— длина массива.
Во второй строке записано положительное число k –— искомый элемент.
Далее в строку через пробел записано n натуральных чисел – элементы массива.

Формат вывода
Функция должна вернуть индекс элемента, равного k, если такой есть в массиве (нумерация с нуля).
Если элемент не найден, функция должна вернуть −1.
Изменять массив нельзя.
Для отсечения неэффективных решений ваша функция будет запускаться от 100000 до 1000000 раз.
"""


def broken_search(nums, target) -> int:
    def search(array, low, high, key):
        if low > high:
            return -1

        mid = (low + high) // 2

        mid_value = array[mid]
        if mid_value == key:
            return mid

        if array[low] <= mid_value:
            if key >= array[low] and key <= mid_value:
                return search(array, low, mid - 1, key)
            return search(array, mid + 1, high, key)

        if key >= mid_value and key <= array[high]:
            return search(array, mid + 1, high, key)
        return search(array, low, mid - 1, key)

    return search(nums, 0, len(nums) - 1, target)
